import React, { useState, useEffect, useRef } from 'react';
import { PaperAirplaneIcon, UserIcon, InformationCircleIcon } from '@heroicons/react/24/outline';
import { useAuth } from '../contexts/AuthContext';
import { useSocket } from '../contexts/SocketContext';
import MessageBubble from './MessageBubble';
import api from '../services/api';
import { Message } from '../types';

interface Chat {
  _id: string;
  id: string;
  nombre: string;
  tipo: 'individual' | 'grupal';
  participantes: Array<{
    id: string;
    name: string;
    carrera: string;
    foto_perfil?: string;
  }>;
  ultimo_mensaje?: {
    contenido: string;
    fecha: string;
    autor?: {
      name: string;
    };
  };
  fecha_creacion: string;
  mensajes_no_leidos: number;
}

interface ChatWindowProps {
  chat: Chat;
  onClose?: () => void;
}

const ChatWindow: React.FC<ChatWindowProps> = ({ chat, onClose }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [sending, setSending] = useState(false);
  const [typingUsers, setTypingUsers] = useState<string[]>([]);
  const [isTyping, setIsTyping] = useState(false);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const { user, token } = useAuth();
  const { 
    isConnected, 
    joinChat, 
    leaveChat, 
    sendMessage: sendSocketMessage, 
    onReceiveMessage, 
    onUserTyping,
    removeListener 
  } = useSocket();

  const chatId = chat._id || chat.id;

  // Join chat room when component mounts
  useEffect(() => {
    if (isConnected && chatId) {
      console.log('Joining chat room:', chatId);
      joinChat(chatId);
    }

    return () => {
      if (chatId) {
        leaveChat(chatId);
      }
    };
  }, [isConnected, chatId, joinChat, leaveChat]);

  // Load messages
  useEffect(() => {
    loadMessages();
  }, [chatId, token]);

  // Set up socket event listeners
  useEffect(() => {
    const handleReceiveMessage = (message: any) => {
      console.log('Mensaje recibido:', message);
      
      // Convert socket message format to our message format
      const formattedMessage: Message = {
        id: message.id || Date.now().toString(),
        _id: message.id || Date.now().toString(),
        chat: chatId,
        contenido: message.message,
        content: message.message,
        autor: {
          id: 'unknown',
          name: message.sender || 'Usuario',
          foto_perfil: null,
          carrera: ''
        },
        fecha_envio: message.timestamp || new Date().toISOString(),
        createdAt: message.timestamp || new Date().toISOString(),
        tipo: 'text',
        messageType: 'text',
        leido: false,
        is_own: false,
        is_read: false
      };

      setMessages(prev => [...prev, formattedMessage]);
    };

    const handleUserTyping = (data: any) => {
      console.log('Usuario escribiendo:', data);
      if (data.chat_id === chatId && data.userId !== user?.id) {
        setTypingUsers(prev => {
          if (data.isTyping && !prev.includes(data.name)) {
            return [...prev, data.name];
          } else if (!data.isTyping) {
            return prev.filter(name => name !== data.name);
          }
          return prev;
        });
      }
    };

    if (isConnected) {
      onReceiveMessage(handleReceiveMessage);
      onUserTyping(handleUserTyping);
    }

    return () => {
      removeListener('receive_message', handleReceiveMessage);
      removeListener('user_typing', handleUserTyping);
    };
  }, [isConnected, chatId, user, onReceiveMessage, onUserTyping, removeListener]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const loadMessages = async () => {
    if (!token || !chatId) {
      setError('Faltan datos para cargar mensajes');
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await api.get(`/chat/${chatId}/messages`, {
        headers: {
          'Authorization': `Bearer ${token}`
        },
        params: {
          limit: 50
        }
      });

      if (response.data.success) {
        setMessages(response.data.data.messages || []);
      } else {
        setError(response.data.message || 'Error cargando mensajes');
      }
    } catch (err: any) {
      console.error('Error loading messages:', err);
      if (err.response?.status === 403) {
        setError('No tienes acceso a este chat');
      } else if (err.response?.status === 404) {
        setError('Chat no encontrado');
      } else {
        setError('Error conectando con el servidor');
      }
    } finally {
      setLoading(false);
    }
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!newMessage.trim() || sending || !token) return;

    const messageText = newMessage.trim();
    setNewMessage('');
    setSending(true);

    try {
      // Send via Socket.IO for real-time delivery
      if (isConnected) {
        sendSocketMessage(chatId, messageText);
      }

      // Also send via HTTP API for persistence
      const response = await api.post(`/chat/${chatId}/messages`, {
        content: messageText,
        messageType: 'text'
      }, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (response.data.success) {
        const sentMessage = response.data.data.message;
        
        // Add message to local state (if not already added by socket)
        setMessages(prev => {
          const exists = prev.some(msg => 
            (msg.id === sentMessage.id || msg._id === sentMessage._id) ||
            (msg.contenido === sentMessage.contenido && 
             Math.abs(new Date(msg.fecha_envio || msg.createdAt || '').getTime() - 
                     new Date(sentMessage.fecha_envio || sentMessage.createdAt || '').getTime()) < 1000)
          );
          
          return exists ? prev : [...prev, sentMessage];
        });
      }
    } catch (err: any) {
      console.error('Error sending message:', err);
      setError(err.response?.data?.message || 'Error enviando mensaje');
      setNewMessage(messageText); // Restore message text
    } finally {
      setSending(false);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setNewMessage(e.target.value);
    
    // Handle typing indicators
    if (isConnected && e.target.value.trim() && !isTyping) {
      setIsTyping(true);
      // TODO: Send typing start event
    }

    // Clear typing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    // Set new timeout to stop typing
    typingTimeoutRef.current = setTimeout(() => {
      if (isTyping) {
        setIsTyping(false);
        // TODO: Send typing stop event
      }
    }, 1000);
  };

  const getOtherParticipant = () => {
    if (chat.tipo === 'grupal') return null;
    return chat.participantes.find(p => p.id !== user?.id) || chat.participantes[0];
  };

  const getChatDisplayName = () => {
    if (chat.tipo === 'grupal') {
      return chat.nombre || 'Chat Grupal';
    }
    const otherUser = getOtherParticipant();
    return otherUser ? otherUser.name : chat.nombre;
  };

  const getChatDisplayInfo = () => {
    if (chat.tipo === 'grupal') {
      return `${chat.participantes.length} participantes`;
    }
    const otherUser = getOtherParticipant();
    return otherUser ? otherUser.carrera : '';
  };

  return (
    <div className="flex flex-col h-full bg-white">
      {/* Header */}
      <div className="flex items-center p-4 border-b border-gray-200 bg-white">
        <div className="flex items-center flex-1">
          {/* Avatar */}
          <div className="flex-shrink-0">
            {chat.tipo === 'individual' ? (
              (() => {
                const otherUser = getOtherParticipant();
                return otherUser?.foto_perfil ? (
                  <img
                    src={otherUser.foto_perfil}
                    alt={otherUser.name}
                    className="h-10 w-10 rounded-full object-cover"
                  />
                ) : (
                  <div className="h-10 w-10 bg-gray-200 rounded-full flex items-center justify-center">
                    <UserIcon className="h-5 w-5 text-gray-500" />
                  </div>
                );
              })()
            ) : (
              <div className="h-10 w-10 bg-blue-100 rounded-full flex items-center justify-center">
                <UserIcon className="h-5 w-5 text-blue-600" />
              </div>
            )}
          </div>

          {/* Chat info */}
          <div className="ml-3 flex-1 min-w-0">
            <h2 className="text-lg font-semibold text-gray-900 truncate">
              {getChatDisplayName()}
            </h2>
            <p className="text-sm text-gray-500 truncate">
              {getChatDisplayInfo()}
            </p>
          </div>
        </div>

        {/* Actions */}
        <div className="flex items-center space-x-2">
          <button
            className="p-2 text-gray-400 hover:text-gray-600 transition-colors"
            title="Información del chat"
          >
            <InformationCircleIcon className="h-6 w-6" />
          </button>
        </div>
      </div>

      {/* Messages area */}
      <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
        {loading && (
          <div className="flex items-center justify-center p-8">
            <div className="animate-spin rounded-full h-8 w-8 border-2 border-blue-600 border-t-transparent"></div>
            <span className="ml-3 text-gray-600">Cargando mensajes...</span>
          </div>
        )}

        {error && (
          <div className="text-center p-4">
            <p className="text-red-600 text-sm">{error}</p>
            <button
              onClick={loadMessages}
              className="mt-2 text-blue-600 hover:text-blue-800 text-sm"
            >
              Reintentar
            </button>
          </div>
        )}

        {!loading && !error && messages.length === 0 && (
          <div className="text-center p-8 text-gray-500">
            <p>No hay mensajes en esta conversación</p>
            <p className="text-sm">¡Envía el primer mensaje!</p>
          </div>
        )}

        {!loading && !error && messages.map((message) => (
          <MessageBubble
            key={message.id || message._id}
            message={message}
            isOwnMessage={message.is_own || (message.autor?.id === user?.id)}
          />
        ))}

        {/* Typing indicator */}
        {typingUsers.length > 0 && (
          <div className="flex mb-3">
            <div className="bg-gray-200 px-4 py-2 rounded-2xl rounded-bl-sm">
              <div className="flex items-center space-x-1">
                <div className="flex space-x-1">
                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                  <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                </div>
                <span className="text-xs text-gray-500 ml-2">
                  {typingUsers.join(', ')} está{typingUsers.length > 1 ? 'n' : ''} escribiendo...
                </span>
              </div>
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Message input */}
      <div className="border-t border-gray-200 bg-white p-4">
        <form onSubmit={handleSendMessage} className="flex items-center space-x-3">
          <div className="flex-1">
            <input
              ref={inputRef}
              type="text"
              value={newMessage}
              onChange={handleInputChange}
              placeholder="Escribe un mensaje..."
              className="w-full px-4 py-3 border border-gray-300 rounded-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
              disabled={sending}
            />
          </div>
          <button
            type="submit"
            disabled={!newMessage.trim() || sending}
            className={`p-3 rounded-full transition-colors ${
              newMessage.trim() && !sending
                ? 'bg-blue-600 text-white hover:bg-blue-700'
                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
            }`}
          >
            {sending ? (
              <div className="animate-spin rounded-full h-5 w-5 border-2 border-white border-t-transparent"></div>
            ) : (
              <PaperAirplaneIcon className="h-5 w-5" />
            )}
          </button>
        </form>
      </div>
    </div>
  );
};

export default ChatWindow;
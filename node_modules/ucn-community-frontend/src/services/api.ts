import axios, { AxiosResponse } from 'axios';
import { AuthResponse, LoginData, RegisterData, ApiResponse, User, Chat, Message } from '../types';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 segundos timeout
});

// Interceptor para agregar token a las peticiones
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Interceptor para manejar respuestas y errores
api.interceptors.response.use(
  (response: AxiosResponse) => {
    // Retornar solo los datos para simplificar el manejo
    return response.data;
  },
  async (error) => {
    const originalRequest = error.config;

    // Si el token expiró, intentar renovarlo
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refreshToken');
        if (refreshToken) {
          const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {
            refreshToken
          });

          const { accessToken } = response.data.data;
          localStorage.setItem('accessToken', accessToken);

          // Reintentar la petición original con el nuevo token
          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Error al renovar token, redirigir a login
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('user');
        
        if (window.location.pathname !== '/login') {
          window.location.href = '/login';
        }
      }
    }

    // Para otros errores 401 o si el refresh falló
    if (error.response?.status === 401) {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
      
      if (window.location.pathname !== '/login') {
        window.location.href = '/login';
      }
    }

    return Promise.reject(error);
  }
);

// API de Autenticación
export const authAPI = {
  login: (data: LoginData): Promise<AuthResponse> => 
    api.post('/auth/login', data),
  
  register: (data: RegisterData): Promise<AuthResponse> => 
    api.post('/auth/register', data),
  
  logout: (): Promise<ApiResponse> => 
    api.post('/auth/logout'),
  
  getProfile: (): Promise<ApiResponse<{ user: User }>> => 
    api.get('/auth/me'),
  
  verifyToken: (token?: string): Promise<ApiResponse> => {
    if (token) {
      return axios.get(`${API_BASE_URL}/auth/verify`, {
        headers: { Authorization: `Bearer ${token}` }
      }).then(res => res.data);
    }
    return api.get('/auth/verify');
  },

  refreshToken: (refreshToken: string): Promise<ApiResponse<{ accessToken: string }>> =>
    axios.post(`${API_BASE_URL}/auth/refresh`, { refreshToken }).then(res => res.data),

  getStatus: (): Promise<ApiResponse> => 
    api.get('/auth/status')
};

// API de Usuarios
export const userAPI = {
  getUsers: (params?: { page?: number; limit?: number; search?: string }): Promise<ApiResponse<{ users: User[]; total: number; page: number; pages: number }>> =>
    api.get('/users', { params }),
  
  getUserById: (id: string): Promise<ApiResponse<{ user: User }>> =>
    api.get(`/users/${id}`),
  
  updateProfile: (data: Partial<User>): Promise<ApiResponse<{ user: User }>> =>
    api.put('/users/profile', data),
  
  uploadAvatar: (formData: FormData): Promise<ApiResponse<{ user: User }>> =>
    api.post('/users/avatar', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    }),

  changePassword: (data: { currentPassword: string; newPassword: string; confirmPassword: string }): Promise<ApiResponse> =>
    api.put('/users/change-password', data),

  searchUsers: (query: string): Promise<ApiResponse<{ users: User[] }>> =>
    api.get(`/users/search?q=${encodeURIComponent(query)}`)
};

// API de Posts
export const postAPI = {
  getPosts: (params?: { page?: number; limit?: number; categoria?: string; search?: string; sortBy?: string }): Promise<ApiResponse<{ posts: any[]; total: number; page: number; pages: number }>> =>
    api.get('/posts', { params }),
  
  getPostById: (id: string): Promise<ApiResponse<{ post: any }>> =>
    api.get(`/posts/${id}`),
  
  createPost: (data: any): Promise<ApiResponse<{ post: any }>> =>
    api.post('/posts', data),
  
  updatePost: (id: string, data: any): Promise<ApiResponse<{ post: any }>> =>
    api.put(`/posts/${id}`, data),
  
  deletePost: (id: string): Promise<ApiResponse> =>
    api.delete(`/posts/${id}`),

  likePost: (id: string): Promise<ApiResponse> =>
    api.post(`/posts/${id}/like`),

  addComment: (id: string, data: { contenido: string }): Promise<ApiResponse<{ comment: any }>> =>
    api.post(`/posts/${id}/comments`, data),

  getMyPosts: (): Promise<ApiResponse<{ posts: any[] }>> =>
    api.get('/posts/my-posts')
};

// API de Chats
export const chatAPI = {
  getChats: (): Promise<ApiResponse<{ chats: Chat[] }>> =>
    api.get('/chats'),
  
  getChatById: (id: string): Promise<ApiResponse<{ chat: Chat }>> =>
    api.get(`/chats/${id}`),
  
  createChat: (data: { nombre: string; descripcion?: string; tipo: string; participantes: string[] }): Promise<ApiResponse<{ chat: Chat }>> =>
    api.post('/chats', data),
  
  joinChat: (id: string): Promise<ApiResponse> =>
    api.post(`/chats/${id}/join`),
  
  leaveChat: (id: string): Promise<ApiResponse> =>
    api.post(`/chats/${id}/leave`),

  getChatMessages: (id: string, params?: { page?: number; limit?: number }): Promise<ApiResponse<{ messages: Message[]; total: number; page: number; pages: number }>> =>
    api.get(`/chats/${id}/messages`, { params }),

  sendMessage: (chatId: string, data: { mensaje: string; tipo?: string }): Promise<ApiResponse<{ message: Message }>> =>
    api.post(`/chats/${chatId}/messages`, data),

  markMessagesAsRead: (chatId: string): Promise<ApiResponse> =>
    api.post(`/chats/${chatId}/read`),

  searchChats: (query: string): Promise<ApiResponse<{ chats: Chat[] }>> =>
    api.get(`/chats/search?q=${encodeURIComponent(query)}`)
};

// Función helper para manejar errores de API
export const handleApiError = (error: any): string => {
  if (error.response?.data?.message) {
    return error.response.data.message;
  }
  
  if (error.response?.data?.errors) {
    return error.response.data.errors.map((e: any) => e.message).join(', ');
  }

  if (error.message) {
    return error.message;
  }

  return 'Error desconocido';
};

// Función helper para reintentar llamadas API
export const retryApiCall = async <T>(
  apiCall: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> => {
  let lastError: any;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await apiCall();
    } catch (error: any) {
      lastError = error;
      
      // No retry for authentication errors or client errors (4xx)
      if (error.response?.status >= 400 && error.response?.status < 500) {
        throw error;
      }
      
      // Don't retry on last attempt
      if (attempt === maxRetries) {
        break;
      }
      
      // Wait before retrying with exponential backoff
      const waitTime = delay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
  
  throw lastError;
};

export default api;
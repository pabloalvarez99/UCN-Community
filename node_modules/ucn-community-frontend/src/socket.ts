import { io, Socket } from 'socket.io-client';
import { OnlineUser, Message } from './types';

const SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:5000';

interface SocketServiceEvents {
  // Connection events
  onUserOnline: (callback: (user: OnlineUser) => void) => void;
  onUserOffline: (callback: (data: { userId: string; name: string; timestamp: Date }) => void) => void;
  onOnlineUsers: (callback: (users: OnlineUser[]) => void) => void;
  
  // Chat events
  onChatJoined: (callback: (data: { chat_id: string; message: string; timestamp: Date }) => void) => void;
  onUserJoinedChat: (callback: (data: { userId: string; name: string; avatar?: string; chat_id: string; timestamp: Date }) => void) => void;
  onUserLeftChat: (callback: (data: { userId: string; name: string; chat_id: string; timestamp: Date }) => void) => void;
  
  // Message events
  onReceiveMessage: (callback: (message: Message) => void) => void;
  
  // Typing events
  onUserTyping: (callback: (data: { userId: string; name: string; chat_id: string; isTyping: boolean; timestamp: Date }) => void) => void;
  
  // Error events
  onError: (callback: (error: { type: string; message: string }) => void) => void;
}

class SocketService implements SocketServiceEvents {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;

  connect(token: string): Socket {
    if (this.socket?.connected) {
      console.log('Socket ya está conectado');
      return this.socket;
    }

    this.socket = io(SERVER_URL, {
      transports: ['websocket', 'polling'],
      auth: {
        token: token
      },
      query: {
        token: token
      },
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: this.reconnectDelay,
      timeout: 10000
    });

    this.setupEventListeners();
    return this.socket;
  }

  private setupEventListeners(): void {
    if (!this.socket) return;

    this.socket.on('connect', () => {
      console.log('✅ Conectado al servidor Socket.IO:', this.socket?.id);
      this.reconnectAttempts = 0;
    });

    this.socket.on('disconnect', (reason: string) => {
      console.log('❌ Desconectado del servidor Socket.IO:', reason);
      
      if (reason === 'io server disconnect') {
        // El servidor desconectó al cliente, reconectar manualmente
        this.socket?.connect();
      }
    });

    this.socket.on('connect_error', (error: any) => {
      console.error('❌ Error de conexión Socket.IO:', error.message);
      this.reconnectAttempts++;
      
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.error('❌ Máximo de intentos de reconexión alcanzado');
      }
    });

    this.socket.on('reconnect', (attemptNumber: number) => {
      console.log(`🔄 Reconectado después de ${attemptNumber} intentos`);
    });

    this.socket.on('error', (error: { type: string; message: string }) => {
      console.error('❌ Error de Socket.IO:', error);
    });
  }

  disconnect(): void {
    if (this.socket) {
      console.log('🔌 Desconectando Socket.IO...');
      this.socket.disconnect();
      this.socket = null;
    }
  }

  isConnected(): boolean {
    return this.socket?.connected || false;
  }

  getSocket(): Socket | null {
    return this.socket;
  }

  // Chat methods - Actualizados para coincidir con eventos del backend
  joinChat(chat_id: string): void {
    if (this.socket) {
      console.log(`👥 Uniéndose al chat: ${chat_id}`);
      this.socket.emit('join_room', chat_id);
    } else {
      console.error('Socket no está conectado');
    }
  }

  leaveChat(chat_id: string): void {
    if (this.socket) {
      console.log(`👋 Saliendo del chat: ${chat_id}`);
      this.socket.emit('leave_room', chat_id);
    }
  }

  sendMessage(chat_id: string, mensaje: string, sender?: string): void {
    if (this.socket) {
      console.log(`💬 Enviando mensaje a sala ${chat_id}:`, mensaje);
      this.socket.emit('send_message', { 
        room: chat_id, 
        message: mensaje,
        sender: sender || 'Usuario'
      });
    } else {
      console.error('Socket no está conectado');
    }
  }

  // Typing methods - Actualizados para coincidir con eventos del backend  
  startTyping(chat_id: string): void {
    if (this.socket) {
      this.socket.emit('typing_start', { room: chat_id });
    }
  }

  stopTyping(chat_id: string): void {
    if (this.socket) {
      this.socket.emit('typing_stop', { room: chat_id });
    }
  }

  // Presence methods
  getOnlineUsers(): void {
    if (this.socket) {
      this.socket.emit('get_online_users');
    }
  }

  // Event listeners
  onUserOnline(callback: (user: OnlineUser) => void): void {
    if (this.socket) {
      this.socket.on('user_online', callback);
    }
  }

  onUserOffline(callback: (data: { userId: string; name: string; timestamp: Date }) => void): void {
    if (this.socket) {
      this.socket.on('user_offline', callback);
    }
  }

  onOnlineUsers(callback: (users: OnlineUser[]) => void): void {
    if (this.socket) {
      this.socket.on('online_users', callback);
    }
  }

  onChatJoined(callback: (data: { chat_id: string; message: string; timestamp: Date }) => void): void {
    if (this.socket) {
      this.socket.on('chat_joined', callback);
    }
  }

  onUserJoinedChat(callback: (data: { userId: string; name: string; avatar?: string; chat_id: string; timestamp: Date }) => void): void {
    if (this.socket) {
      this.socket.on('user_joined_chat', callback);
    }
  }

  onUserLeftChat(callback: (data: { userId: string; name: string; chat_id: string; timestamp: Date }) => void): void {
    if (this.socket) {
      this.socket.on('user_left_chat', callback);
    }
  }

  onReceiveMessage(callback: (message: Message) => void): void {
    if (this.socket) {
      this.socket.on('receive_message', callback);
    }
  }

  onUserTyping(callback: (data: { userId: string; name: string; chat_id: string; isTyping: boolean; timestamp: Date }) => void): void {
    if (this.socket) {
      this.socket.on('user_typing', callback);
    }
  }

  onError(callback: (error: { type: string; message: string }) => void): void {
    if (this.socket) {
      this.socket.on('error', callback);
    }
  }

  // Remove listeners
  off(eventName: string, callback?: (...args: any[]) => void): void {
    if (this.socket) {
      if (callback) {
        this.socket.off(eventName, callback);
      } else {
        this.socket.off(eventName);
      }
    }
  }

  removeAllListeners(): void {
    if (this.socket) {
      this.socket.removeAllListeners();
      this.setupEventListeners(); // Re-add connection listeners
    }
  }
}

const socketService = new SocketService();
export default socketService;
import React, { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';
import { useAuth } from './AuthContext';
import socketService from '../socket';
import { OnlineUser, Message } from '../types';

interface Notification {
  id: string;
  type: 'message' | 'user_online' | 'system';
  title: string;
  message: string;
  timestamp: Date;
  read: boolean;
  data?: any;
}

interface SocketContextType {
  isConnected: boolean;
  onlineUsers: OnlineUser[];
  socket: typeof socketService;
  notifications: Notification[];
  unreadCount: number;
  
  // Chat methods
  joinChat: (chatId: string) => void;
  leaveChat: (chatId: string) => void;
  sendMessage: (chatId: string, message: string) => void;
  
  // Typing methods
  startTyping: (chatId: string) => void;
  stopTyping: (chatId: string) => void;
  
  // Event handlers
  onReceiveMessage: (callback: (message: Message) => void) => void;
  onUserTyping: (callback: (data: { userId: string; name: string; chat_id: string; isTyping: boolean }) => void) => void;
  onUserOnline: (callback: (user: OnlineUser) => void) => void;
  onUserOffline: (callback: (data: { userId: string; name: string }) => void) => void;
  
  // Notifications
  addNotification: (notification: Omit<Notification, 'id' | 'timestamp'>) => void;
  markNotificationAsRead: (notificationId: string) => void;
  clearAllNotifications: () => void;
  
  // Cleanup
  removeListener: (event: string, callback?: (...args: any[]) => void) => void;
}

const SocketContext = createContext<SocketContextType | undefined>(undefined);

export const useSocket = () => {
  const context = useContext(SocketContext);
  if (context === undefined) {
    throw new Error('useSocket debe ser usado dentro de SocketProvider');
  }
  return context;
};

interface SocketProviderProps {
  children: ReactNode;
}

export const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {
  const { user, token, isAuthenticated } = useAuth();
  const [isConnected, setIsConnected] = useState(false);
  const [onlineUsers, setOnlineUsers] = useState<OnlineUser[]>([]);
  
  // Notifications state
  const [notifications, setNotifications] = useState<Notification[]>([]);

  // Notification methods
  const addNotification = useCallback((notification: Omit<Notification, 'id' | 'timestamp'>) => {
    const newNotification: Notification = {
      ...notification,
      id: Date.now().toString(),
      timestamp: new Date()
    };
    setNotifications(prev => [newNotification, ...prev]);
  }, []);

  const markNotificationAsRead = useCallback((notificationId: string) => {
    setNotifications(prev => 
      prev.map(notif => 
        notif.id === notificationId 
          ? { ...notif, read: true } 
          : notif
      )
    );
  }, []);

  const clearAllNotifications = useCallback(() => {
    setNotifications([]);
  }, []);

  const unreadCount = notifications.filter(n => !n.read).length;

  // Initialize socket connection when user is authenticated
  useEffect(() => {
    if (isAuthenticated && token && user) {
      console.log('🔌 Iniciando conexión Socket.IO...');
      
      try {
        const socket = socketService.connect(token);
        
        // Connection event handlers
        const handleConnect = () => {
          console.log('✅ Socket.IO conectado');
          setIsConnected(true);
          socketService.getOnlineUsers();
        };

        const handleDisconnect = () => {
          console.log('❌ Socket.IO desconectado');
          setIsConnected(false);
        };

        const handleConnectError = (error: any) => {
          console.error('❌ Error de conexión Socket.IO:', error);
          setIsConnected(false);
        };

        // Presence event handlers
        const handleOnlineUsers = (users: OnlineUser[]) => {
          setOnlineUsers(users);
        };

        const handleUserOnline = (user: OnlineUser) => {
          setOnlineUsers(prev => {
            const filtered = prev.filter(u => u.userId !== user.userId);
            return [...filtered, user];
          });
          
          // Add notification for user coming online
          addNotification({
            type: 'user_online',
            title: 'Usuario conectado',
            message: `${user.name} se ha conectado`,
            read: false
          });
        };

        const handleUserOffline = (data: { userId: string; name: string }) => {
          setOnlineUsers(prev => prev.filter(u => u.userId !== data.userId));
        };

        // Error handler
        const handleError = (error: { type: string; message: string }) => {
          console.error('❌ Error Socket.IO:', error);
          
          // Handle authentication errors
          if (error.type === 'AUTHENTICATION_ERROR') {
            console.error('❌ Error de autenticación Socket.IO, desconectando...');
            socketService.disconnect();
            setIsConnected(false);
          }
        };

        // Set up event listeners
        socket.on('connect', handleConnect);
        socket.on('disconnect', handleDisconnect);
        socket.on('connect_error', handleConnectError);
        socket.on('online_users', handleOnlineUsers);
        socket.on('user_online', handleUserOnline);
        socket.on('user_offline', handleUserOffline);
        socket.on('error', handleError);

        return () => {
          // Clean up event listeners
          socket.off('connect', handleConnect);
          socket.off('disconnect', handleDisconnect);
          socket.off('connect_error', handleConnectError);
          socket.off('online_users', handleOnlineUsers);
          socket.off('user_online', handleUserOnline);
          socket.off('user_offline', handleUserOffline);
          socket.off('error', handleError);
        };

      } catch (error) {
        console.error('❌ Error al inicializar Socket.IO:', error);
        setIsConnected(false);
      }
    }
  }, [isAuthenticated, token, user, addNotification]);

  // Disconnect when user logs out
  useEffect(() => {
    if (!isAuthenticated) {
      console.log('🔌 Desconectando Socket.IO por logout...');
      socketService.disconnect();
      setIsConnected(false);
      setOnlineUsers([]);
    }
  }, [isAuthenticated]);

  // Chat methods
  const joinChat = useCallback((chatId: string) => {
    if (isConnected) {
      socketService.joinChat(chatId);
    }
  }, [isConnected]);

  const leaveChat = useCallback((chatId: string) => {
    if (isConnected) {
      socketService.leaveChat(chatId);
    }
  }, [isConnected]);

  const sendMessage = useCallback((chatId: string, message: string) => {
    if (isConnected && user) {
      socketService.sendMessage(chatId, message, user.name);
    }
  }, [isConnected, user]);

  // Typing methods
  const startTyping = useCallback((chatId: string) => {
    if (isConnected) {
      socketService.startTyping(chatId);
    }
  }, [isConnected]);

  const stopTyping = useCallback((chatId: string) => {
    if (isConnected) {
      socketService.stopTyping(chatId);
    }
  }, [isConnected]);

  // Event handlers
  const onReceiveMessage = useCallback((callback: (message: Message) => void) => {
    if (socketService.getSocket()) {
      socketService.onReceiveMessage(callback);
    }
  }, []);

  const onUserTyping = useCallback((callback: (data: { userId: string; name: string; chat_id: string; isTyping: boolean }) => void) => {
    if (socketService.getSocket()) {
      socketService.onUserTyping(callback);
    }
  }, []);

  const onUserOnline = useCallback((callback: (user: OnlineUser) => void) => {
    if (socketService.getSocket()) {
      socketService.onUserOnline(callback);
    }
  }, []);

  const onUserOffline = useCallback((callback: (data: { userId: string; name: string }) => void) => {
    if (socketService.getSocket()) {
      socketService.onUserOffline(callback);
    }
  }, []);

  const removeListener = useCallback((event: string, callback?: (...args: any[]) => void) => {
    socketService.off(event, callback);
  }, []);

  const value: SocketContextType = {
    isConnected,
    onlineUsers,
    socket: socketService,
    notifications,
    unreadCount,
    joinChat,
    leaveChat,
    sendMessage,
    startTyping,
    stopTyping,
    onReceiveMessage,
    onUserTyping,
    onUserOnline,
    onUserOffline,
    addNotification,
    markNotificationAsRead,
    clearAllNotifications,
    removeListener
  };

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
};